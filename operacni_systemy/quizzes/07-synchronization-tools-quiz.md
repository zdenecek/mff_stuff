# Process Synchronization Tools

This is a graded quiz, do not forget to commit and push your responses in time (deadline is end of November 16).


## Atomics

**[Q1]** Following is a simple code fragment in C that exercises several atomic operations defined by the C standard:

```c
#include <stdbool.h>
#include <stdatomic.h>

atomic_int a;
volatile bool b;
volatile int i;

void silly (void) {
    atomic_init (&a, i);
    atomic_store (&a, i);
    i = atomic_load (&a);
    i = atomic_exchange (&a, i);
    i = atomic_fetch_add (&a, i);
    b = atomic_compare_exchange_strong (&a, &i, i);
}
```

Using the gcc compiler, determine how the individual operations are implemented on the Intel and MIPS processors.
Specifically, for each processor, list which operations correspond to a single processor instruction,
which operations correspond to multiple processor instructions, and which operations are implemented
with a loop. The question concerns only the atomic part of the operation, ignore the instructions
that just serve to prepare the arguments.

There are many ways of figuring out the answer. If you prefer playing with the gcc compiler on the command line,
you may want to look at the `-S` option to dump the generated assembly, together with the `-fverbose-asm` option
that enables more comments throughout the assembly output. Alternatively, you can use the compiler explorer
at http://www.godbolt.org with the gcc x86_64 12.2 and gcc mips (el) 12.2.0 compilers, in that case
remember to switch to C (not C++) for the source to compile. In any case, use `-O` to examine
optimized code.

**[A1]** ... **[/A1]**


## Semaphores

**[Q2]** We have decided to use semaphores to implement locks, like this:

```c
typedef struct lock { sem_t inner_semaphore; } lock_t;

void lock_init (lock_t *lock) { sem_init (&lock->inner_semaphore, 0, 1); }
void lock_lock (lock_t *lock) { sem_wait (&lock->inner_semaphore); }
void lock_unlock (lock_t *lock) { sem_post (&lock->inner_semaphore); }
```

Here is an alternative implementation, which wraps `pthread_mutex_t` with the same interface:

```c
typedef struct lock { pthread_mutex_t inner_mutex; } lock_t;

void lock_init (lock_t *lock) { pthread_mutex_init (&lock->inner_mutex, NULL); }
void lock_lock (lock_t *lock) { pthread_mutex_lock (&lock->inner_mutex); }
void lock_unlock (lock_t *lock) { pthread_mutex_unlock (&lock->inner_mutex); }
```

Use `man` on Linux for information on the semaphore and mutex functions if needed.

Decide whether it is possible to distinguish the two implementations
from each other just by invoking the lock functions, without
relying on any undefined behavior (such as unlocking lock
held by other thread). Assume the mutex is of the
non robust `PTHREAD_MUTEX_DEFAULT` type.

**[A2]** I can't think of any way to distinguish between the two implementations. The expected behaviour should match exactly. **[/A2]**


## Condition Variables

**[Q3]** Consider the code of the following two threads:

```c
static pthread_cond_t cond; // Initialized elsewhere.
static pthread_mutex_t mutex; // Initialized elsewhere.

atomic_int x = 0;

void *thread_one_function (void *dummy) {
    while (true) {
        pthread_mutex_lock (&mutex);
        x = rand ();
        if (x == 10) {
            pthread_cond_signal (&cond);
        }
        pthread_mutex_unlock (&mutex);
    }
}

void *thread_two_function (void *dummy) {
    pthread_mutex_lock (&mutex);
    pthread_cond_wait (&cond, &mutex);
    printf ("%d\n", x);
    pthread_mutex_unlock (&mutex);
}
```

What are the possible outputs printed by this code ? (No other threads access `x`, the `rand` function simply returns a random integer.)

**[A3]** Any one number that can be generated by rand(). When pthread_cond_signal is called, thread two is locked, so it cannot wake up immediately. It will wake sometime later, when x could have been changed. **[/A3]**


## Ask Your Question

**[Q0]** Ask a single question concerning the topic of the next self study module.

**[A0]** How can I correctly select a synchronization primitive when implementing synchronization? **[/A0]**
